#!/usr/bin/python

import sys
import os
from tasklib import TaskWarrior

# == VARIABLES ==

time_attrs_to_shift = ('wait', 'scheduled')
tw = TaskWarrior(data_location=os.path.dirname(os.path.dirname(sys.argv[0])))
tw.overrides.update(dict(recurrence="no", hooks="no"))

# == FUNCTIONS ==

def is_new_local_recurrence_child_task(task):
    """Return True if task was generated by recurrence, and is new."""

    # If task has no parent (i.e. its "parent" attribute equates False),
    # return False. Why? Because then task is *presumably* not a child &
    # therefore *presumably* was not generated by recurrence.
    if not task['parent']:
        return False

    # If task's "modified" attribute is older than is "entry" attribute,
    # return True. Why? We already (see earlier code block) believe task
    # to have been generated by recurrence. A property of such tasks,
    # that seems *only* to hold when they are newly-generated (so new
    # that they have not yet been assigned an ID), is that their
    # "modified attribute is a direct copy of the parent's "modified"
    # attribute, & thus older than the "entry" attribute.
    if (task['modified'] - task['entry']).total_seconds() < 0:
        return True

def hook_shift_recurrence(task):
    if is_new_local_recurrence_child_task(task):
        parent = tw.tasks.get(uuid=task['parent']['uuid'])
        parent_due_shift = task['due'] - parent['due']
        for attr in time_attrs_to_shift:
            if parent[attr]:
                task[attr] = parent[attr] + parent_due_shift
